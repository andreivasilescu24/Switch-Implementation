1 2 3

** create_bpdu_packet **
In aceasta functie creex pachetul BPDU ce va avea partea de Ethernet, ce va contine MAC-ul destinatie specific BPDU
(01:80:C2:00:00:00), MAC-ul sursa (MAC-ul switch-ului) si un camp pentru LLC_LENGTH ce va fi in cazul meu 15 (mai jos 
voi descrie structura cadrului pe care am ales-o). Apoi voi avea LLC Header-ul ce va fi format din 3 bytes, 0x42, 0x42 si
0x03 asa cum este indicat in enunt. De asemenea, voi pune in pachet si BPDU Header-ul format din 4 bytes toti setati pe 0,
urmat de payload-ul BPDU ce contine ID-ul root bridge-ului pe 2 bytes, root path cost-ul pe 4 bytes si ID-ul bridge-ului
pe 2 bytes. Astfel, in total LLC_LENGTH va fi 3 + 4 + 8 = 15 bytes. Toate aceste parti ale pachetului final au fost create 
cu ajutorul "struct.pack", apoi vor fi unite sirurile de bytes in ordinea corecta pentru a alcatui pachetul BPDU final ce va
fi returnat.

** send_bdpu_every_sec **
Functia pe care o apeleaza thread-ul ce trimite pachete BPDU. Acesta va trimite aceste pachete cat timp switch-ul considera
ca el este root bridge-ul, la interval de o secunda, trimitand pe toate porturile de tip Trunk ale switch-ului, pachete 
create cu functia descrisa mai sus, cu root path cost egal cu 0 deoarece fiecare switch considera ca este root bridge, cat timp
trimite aceste pachete.

** isUnicast **
Daca cel mai putin semnificativ bit din adresa MAC este setat va fi o adresa multicast si se va returna False, daca nu, va fi
o adresa unicast si se va returna True.

** is_vlan_tag_needed **
Aceasta functie va verifica daca este nevoie sa fie pus tag-ul de VLAN in pachetul ce urmeaza sa fie trimis. Astfel, se va 
verifica daca interfata pe care se trimite pachetul este de tip Trunk (se va pune tag) sau este de tip access si
de vlan egal cu cea pe care a fost primit pachetul (nu se va pune tag).

** send_vlan_packets **
Aceasta functie va trimite pachetele cu sau fara tag-ul de VLAN dupa caz. Daca se primeste pachetul pe un trunk se va
verifica daca este nevoie sa fie pus tag-ul de VLAN pe interfata pe care trebuie sa trimitem in continuare. Daca este,
trimitem pachetul exact cum l-am primit deoarece deja are tag-ul venind de pe un Trunk. Daca nu este nevoie, scoatem tag-ul 
din pachet, scazand 4 bytes din lungimea pachetului pe care il trimitem fata de cea a pachetului primit deoarece atat ocupa 
tag-ul. Daca s-a primit pe un port access, daca trebuie pus tag-ul de VLAN il vom adauga cu ajutorul functiei "create_vlan_tag" 
si vom creste lungimea pachetului pe care il trimitem cu 4 fata de cel primit. Daca nu este nevoie de tag, trimitem pachetul exact 
cum l-am primit.

** is_vlan_compatible **
Functia verifica daca este permisa trimiterea unui pachet pe o interfata in functie de tipul portului si de VLAN-ul
de pe care a venit pachetul.
Este compatibil pachetul cu interfata daca:
-s-a primit un pachet pe un port de tip Trunk si se trimite pachetul pe un alt port Trunk sau pe un port de VLAN egal
cu vlan-ul din pachet
-se trimite pachetul pe un port de tip Trunk
-se primeste pachetul pe un port de tip access cu vlan egal cu cel al portului access pe care trebuie trimis
Altfel este incompatibil, in concluzie nu se va mai trimite pachetul in continuare pe acea interfata


Pentru inceput, am creat trei dictionare "Table" ce va reprezenta tabela CAM a switch-ului, "switch_interfaces" ce va
va fi o asociere intre index-ul interfetei citita din fisierul de configurare corespunzator switch-ului si tipul portului,
adica VLAN-ul din care face parte sau Trunk si "port_states" unde se va retine starea fiecarei interfete (LISTENING/BLOCKING). 
Voi citi apoi din fisierul de configurare asociat switch-ului bridge id-ul si liniile ce se refera la tipul portului (VLAN 'X' 
sau Trunk), completand in continuare dictionarele "switch_interfaces" si "port_states". Pe masura ce parcurg liniile din fisier
voi incrementa un index corespunzator interfetelor, in ordinea in care sunt citite, si voi completa dictionarul "switch_interfaces"
ce va avea ca chei index-ul amintit anterior ce va reprezenta interfata, iar ca valori tipul de port, ce va fi un numar, fie
VLAN-ul din care face parte, fie -1 ce va insemna ca este vorba despre un port Trunk. De asemenea, in "port_states", vor fi ca
si chei, aceeasi indecsi ca in celalat dictionar, iar valorile se vor initializa fie cu "BLOCKNG" pentru porturile de tip Trunk,
fie cu "LISTENING" pentru celalalte porturi. Apoi, se vor trece toate porturile switch-ului de tip Trunk pe "LISTENING', daca 
bridge_id este egal cu root_brdge_id, conditie validata la inceput pentru toate switch-urile, deoarece la inceputul STP-ului
fiecare switch crede ca este root bridge. Se va porni, de asemenea un thread ce va trimite la interval de o secunda un pachet
BPDU daca switch-ul inca este considerat root bridge, prin functia "send_bdpu_every_sec" (in final doar root bridge-ul va trimite
pachete BPDU). De asemenea voi folosi o variabila globala pentru ID-ul root bridge-ului pentru ca aceasta sa fie vizibila atat 
in functia main, cat si in functia thread-ului "send_bdpu_every_sec", atunci cand ii este modificata valoarea.

Dupa toate aceste intializari, necesare la pornirea switch-ului, se va intra in bucla in care se vor primi pachete. Daca pachetul
primit este un BPDU (MAC-ul destinatie este 01:80:C2:00:00:00) voi extrage ID-ul root bridge-ului, root path cost-ul si ID-ul 
bridge-ului de unde a venit pachetul, cu ajutorul "struct.unpack", unde ID-ul root bridge-ului si ID-ul bridge-ului vor fi
variabile de tip SHORT si root path cost-ul va fi INT. Respectand pseudocodul din enunt, voi verifica intai daca root
bridge ID-ul primit in pachet este mai mic decat root ridge ID-ul retinut de switch pana in acel moment, iar daca aceasta conditie
se valideaza, se va updata ID-ul root bridge-ului retinut in switch cu noul ID primit in pachet, iar la root path cost
se va adauga 10, costul unei legaturi, iar variabila in care se retine root port-ul se va actualiza cu interfata pe care s-a primit
pachetul. Daca switch-ul considera ca el este root bridge-ul inainte de primirea pachetului, va trece toate porturile trunk ale sale
pe "BLOCKING", iar root port-ul va fi pe "LISTENING". Apoi, se va crea un pachet BPDU cu noile valori pentru ID-ul root bridge-ului
si pentru root path cost si se va trimite pe toate porturile de tip trunk ale switch-ului, dar nu si pe root port. Daca pachetul BPDU
primit este chiar de la root bridge-ul retinut de switch la acel moment, se va verifica daca pachetul a fost primit pe root port, iar 
daca root path cost-ul primit + inca 10 (costul legaturii pe care s-a primit) este mai mic decat root path cost-ul retinut de switch
se va updata aceasta valoare cu root path cost-ul primit + 10. Daca nu s-a primit pachetul pe root port si root_path_cost-ul
primit este mai mare decat cel retinut de switch se va actualiza starea interfetei pe care s-a primit pachetul la "LISTENING" in 
cazul in care nu era deja. Daca pachetul BPDU are acelasi bridge ID in componenta acestuia ca si bridge ID-ul switch-ului vom trece
interfata pe care am primit la "BLOCKING" pentru a evita buclele. Daca niciunul din cazurile de mai sus, se va arunca pachetul.
De asemenea, se va mai face o verificare, daca in urma acestor cazuri, switch-ul este root bridge se vor pune toate porturile acestora
pe "LISTENING".

Daca pachetul primit nu este un BPDU si interfata pe care am primit este pe "LISTENING" vom pune in tabela CAM o noua intrare, cu MAC-ul
sursa a pachetului si interfata pe care am primit. Daca mesajul primit este Unicast si avem MAC-ul destinatie in tabela CAM, verificam
daca interfata pe care trebuie sa trimitem este pe LISTENING is daca este compatibila cu VLAN-ul pachetului, iar daca cele doua conditii
se valideaza, vom trimite pachetul. Daca nu avem MAC-ul destinatie in tabela CAM, vom trimite pe toate interfetele switch-ului care sunt pe
LISTENING si care sunt compatibile cu VLAN-ul pachetului, mai putin cea pe care tomcai am primit. Daca pachetul este unul multicast, vom
aplica acelasi algoritm ca atunci cand nu avem MAC-ul in tabela, vom trimite pachetul pe toate interfetele switch-ului care sunt pe 
LISTENING si sunt compatibile cu VLAN-ul pachetului, mai putin cea pe care am primit. 

